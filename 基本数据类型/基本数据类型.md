# 数据类型的分类与存储位置的差异

- 分类:数据分为基本数据类型和引用数据类型。

- 区别:
  - 基本数据类型：数据直接存储在栈中；
  - 引用数据类型：存储在栈中的是对象的引用地址，真实的对象数据存放在堆内存里。





# 基本数据类型分类

四类:

- 整数型:byte,short,int,long
- 浮点型:float和double
- 字符型:char
- 布尔型:boolean

![image-20220423210322974](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20220423210322974.png)

# 在java虚拟机中基本数据类型的大小:

**Java虚拟机每调用一个方法，便会创建一个栈帧** 

这种栈帧有两个主要的组成部分，分别是局部变量区，以及字节码的操作数栈。

在Java虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了long、double值需要用两个单元来存储外，其它基本类型以及引用类型的值均占用一个数组单元(Slot)。

也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。

当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，**它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合**。

因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把  0xFFFFFFFF（-1）存储到一个声明为 char  类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。

boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而 boolean  数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot  在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。

讲完了存储，现在我来讲讲加载。Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。

对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。

对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short  的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0  来填充，否则用 1 来填充。



# [敏感数据处理时不能使用float与double](https://mp.weixin.qq.com/s/UyYDt3HB8IO_AoSDLndhxA)

解决:

- 方法一: 用字符串或数组解决多为数问题(算法题常见)

- 方法二:java.math包下的大数类BigInteger和BigDecimal是处理高精度计算的理器







